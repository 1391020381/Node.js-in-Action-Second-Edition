# Node功能的组织及重用
* 模块是Node的一种代码组织和包装的方式
* `Node模块打包代码是为了重用,但它们不会改变全局作用域。`
* Node模块允许从被引入文件中选择要暴露给程序的函数和变量。
* npm init -y 参数-y表示yes.这样npm就会创建一个全部使用默认值得 package.json文件。

## 创建模块
* 模块既可以是一个文件,也可以是包含一个多个文件的目录。如果模块是一个目录,Node通常会在这个目录下找一个叫index.js的文件作为模块的入口(这个是默认设置可以重写)  
* 使用新模块要用到Node的require函数,该函数以所用模块的路径为参数。Node以同步的方式寻找模块,定位到这个模块并加载文件中的内容。`Node查找文件的顺序是先找核心模块,然后是当前目录,最后是node_modules`。

## 关于require和同步I/O 
* require是Node中少数几个同步I/O操作之一。因为经常用到模块,并且一般都是在文件顶端引入,所以把require做成同步的有利于保持代码的整洁、有序、还能增强可读性。
* 但是I/O密集的地方尽量不要用require。所有同步调用都会阻塞Node,直到调用完成才能做其他事情。比如你在运行一个HTTP服务器,如果在每个进入的请求上都用了require,就会遇到性能问题。所以require和其他同步操作通常放在程序最初加载的地方。
  

 * 在Node定位到并计算好你的模块之后,`require函数会返回这个模块中定义的 exports对象中的内容`,然后你就可以用这个模块中的函数或变量。 
## 用module.exports微调模块的创建
* `因为Node觉得不能用任何其他对象、函数或变量给 exports赋值`
* 用 module.exports可以对外提供单个变量、函数或者对象。
* 如果你创建了一个既有exports又有 module.exports的模块,那它会返回module.exports，而exports会被忽略。

## 到出的究竟是什么
* 最终在程序里导出的是 module.exports。exports只是对module.exports的一个全局引用,最初被定义为一个可以添加属性的空对象。exports.myFunc只是 module.exports.myFunc的简写。
* 所以,如果把exports设定为别的,就打破了module.exports和exports之间的引用关系。可是因为真正导出的是module.exports,那样exports就不能用了,因为它不再执向module.exports了。如果你想保留那个链接,可以像下面这样让module.exports再次引用 exports:
  
  ```
  module.exports = exports = Currency
  ```
* 根据需要使用 exports或module.exports可以将功能组织成模块,规避掉程序脚本一直增长所产生的弊端。 
## 用node_modules重用模块  

* 使用环境变量NODE_PATH可以改变Node模块的默认路径。如果用了它,在Windows中NODE_PATH应该设置为分号分隔的目录列表,在其他操作系统中则用冒号分隔。
### 注意事项 
1. 如果模块目录,在模块目录中定义模块的文件必须被命令为index.js，除非你在这个目录下有一个叫package.json的文件里特别指明。要指定一个取代index.js的文件,package.json文件里必须有一个用javasctipt对象表示法(json)数据定义的对象,其中有一个mian的键,指明模块目录内主文件的路径。
2. Node能把模块作为对象缓存起来。如果程序中的两个文件引入了相同的模块,第一个require会把模块返回的数据存到内存中,这样第二个require就不用再出访问和计算模块饿源文件了。也就是说,在同一个进程中用require加载一个模块得到的是相同的对象。
3. 假设你搭建了一个MVCWeb应用程序,它有一个主对象app。你可以设置好那个app对象,导出它,然后再项目中任何地方require它。如果你在这个app对象中放了一些配置信息,那你就可以在其他文件中访问这个配置信息的值。j

## 使用异步编程技术   
* 在Node的世界里流行两种响应逻辑管理方式:回调和事件监听。
1. 回调通常来定义一次性响应的逻辑。
2. 事件监听器本质上也是一个回调,不同的是,它跟一个概念实体(事件)想关联。  

### 用回调处理一次性事件
* 回调是一个函数,它被当做参数传给异步参数,用来描述异步操作完成之后要做什么。 

#### Node的异步回调惯例
* Node中大多数内置模块在使用回调时都会带有两个参数:第一个用来放可能会发生的错误,第二个用来放结果。错误参数经常缩写为err。  


##### event.EventEmitter
* clients {} 发布者
* subscriptions {} 订阅者
* on  绑定事件
* emit 触发事件
* join 添加发布者事件

### 异步开发的难题
* 异步逻辑的顺序化
* 让一组异步任务顺序执行的概念被Node社区称为流程控制。这种控制分为两类:串行和并行
* 跟踪串行和并行的流程控制要做编程记账的工作。在实现串行化流程控制时,需要跟踪当前执行的任务,或维护一个尚未执行任务队列。实现并行化流程控制时需要跟踪有多少个任务要执行完成了。
  
* 实现串行化流程控制,需要先把这些任务按预期的执行顺序放到一个数组中。 这个数组将起到队列的作用:完成一个任务后按顺序从数组中取出下一个 
  
